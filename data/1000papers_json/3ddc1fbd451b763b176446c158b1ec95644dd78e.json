{
    "paper_id": "3ddc1fbd451b763b176446c158b1ec95644dd78e",
    "metadata": {
        "title": "The Future is Big Graphs! A Community View on Graph Processing Systems",
        "authors": [
            {
                "first": "Sherif",
                "middle": [],
                "last": "Sakr",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Angela",
                "middle": [],
                "last": "Bonifati",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Hannes",
                "middle": [],
                "last": "Voigt",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Alexandru",
                "middle": [],
                "last": "",
                "suffix": "",
                "affiliation": {},
                "email": ""
            }
        ]
    },
    "abstract": [],
    "body_text": [
        {
            "text": "underpinning many emerging, but already complex and diverse data management ecosystems, in many areas of societal interest 1 . To name only a few remarkable examples of late, the importance of this field for practitioners is evidenced by the large number (over 60,000) of people registered 2 to download the Neo4j book \"Graph Algorithms\" 3 in just over 1.5 years, and by the enormous interest in the use of graph processing in the Artificial Intelligence and Machine Learning fields. 4 Furthermore, the timely Graphs4Covid-19 initiative 5 provides evidence for the importance of big graph analytics in alleviating the global COVID-19 pandemic.",
            "cite_spans": [
                {
                    "start": 123,
                    "end": 124,
                    "text": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 353,
                    "end": 356,
                    "text": "1.5",
                    "ref_id": null
                },
                {
                    "start": 484,
                    "end": 485,
                    "text": "4",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "To address the growing presence of graphs, academics, start-ups, but also big tech companies such as Google, Facebook, and Microsoft, have introduced various systems for managing and processing big graphs. Google's PageRank (late-1990s) showcased the power of web-scale graph processing; and motivated the development of the MapReduce programming model, which was originally used to simplify the construction of the data structures used to handle searches, but has since been used extensively outside of Google to implement algorithms for large-scale graph processing.",
            "cite_spans": [
                {
                    "start": 224,
                    "end": 236,
                    "text": "(late-1990s)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Motivated by scalability, Google Pregel model of \"think like a vertex\" (2010) enabled distributed PageRank computation, while the Facebook and Apache Giraph and ecosystem extensions support more elaborate computational models (i.e., task-based and not always distributed) and data models (i.e., diverse, possibly streamed, possibly wide-area data sources) useful for social network data. Simultaneously, an increasing number of use cases revealed RDBMS performance problems on management of highly connected data, motivating various startups and innovative products, such as Neo4j, Sparksee, and the current Amazon Neptune. Microsoft Trinity and later Azure SQL DB provided an early distributed database-oriented approach to big graph management.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "The diversity of models and systems led initially to the fragmentation of the market and a lack of clear direction for the community. Opposing this trend, we see promising efforts to bring together the programming languages, the ecosystem structure, and the performance benchmarks. As we have argued, there is no single most-common (\"killer\") application, so the community cannot be brought together around it.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Co-authored by a representative sample of the community, this article addresses the questions: How do the nextdecade big graph processing systems look like from the perspectives of the data management and the large scale systems communities 6 ? What can we say today about the guiding design principles of these systems in the next 10 years? Figure 1 outlines the complex pipeline of future big graph processing systems. Data flows in from diverse sources (already graph-modelled as well as non-graph-modelled), is persisted, managed and manipulated with OnLine Transactional Processing operations, such as insertion, deletion, update, filtering, projection, joining, uniting, intersecting, analysed, enriched, and condensed with OnLine Analytical Processing operations, such as grouping, aggregating, slicing, dicing, rollup, and gets disseminated and consumed by machine learning (e.g., ML libraries and processing frameworks), business intelligence (e.g., report generating and planning tools), scientific computing, and visualization and augmented reality applications (for inspection and interaction by the user). Note that this is typically not a purely linear process and hybrid OLTP/OLAP processes can emerge. Considerable complexity stems from (intermediate) results being fed back into early process steps, as indicated by the blue arrows. 1 As indicated by a user survey [12] and by a systematic literature survey of 18 Fig. 1 . Illustration of a complex data pipeline for graph processing. Data is flowing left to right, from data source to output, though a series of functionally different processing steps. Feedback and loopbacks flow mainly through the blue (highlighted) arrows.",
            "cite_spans": [
                {
                    "start": 241,
                    "end": 242,
                    "text": "6",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1350,
                    "end": 1351,
                    "text": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1382,
                    "end": 1386,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1428,
                    "end": 1430,
                    "text": "18",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [
                {
                    "start": 342,
                    "end": 350,
                    "text": "Figure 1",
                    "ref_id": null
                },
                {
                    "start": 1431,
                    "end": 1437,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": ""
        },
        {
            "text": "As an example, to study coronaviruses and their impact on the human and animal populations (e.g., the COVID-19 disease), the pipeline depicted in Figure 1 could be purposed for two major kinds of analysis: network-based 'omics' and drug-related search, and network-based epidemiology and spread-prevention. For the former, the pipeline could have the following steps: the initial genome sequencing leads to identifying similar diseases, then text (non-graph data) and structured (database) searches help identify genes related to the disease, then a network treatment coupled with various kinds of simulations could reveal various drug targets and valid inhibitors, could lead to effective prioritization of usable drugs and treatments. For the latter, social media and location data, and data from other privacy-sensitive sources, could be combined into social interaction graphs, which could be traversed to establish super-spreaders and super-spreading events related to them, leading to prevention policies and containment actions.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 146,
                    "end": 154,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": ""
        },
        {
            "text": "However, the current generation of graph processing technology cannot support such a complex pipeline. For instance, on the COVID-19 knowledge graph, 7 even though useful queries can be posed against individual graphs 8 inspecting the papers, patents, genes, and most influential authors related to COVID-19, a full-fledged graph processing pipeline across multiple (graph-)datasets as illustrated in Figure 1 inspecting several data sources raises many challenges for the current graph database technology. In this paper, we formulate these challenges and build our vision for next-generation, big graph processing systems by focusing on three major aspects: abstractions, ecosystem, and performance.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 401,
                    "end": 409,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": ""
        },
        {
            "text": "First, we present expected data models and query languages, and inherent relationships among them in lattice of abstractions. We discuss (in Section 2) these abstractions and the flexibility of the lattice structures in accommodating future graph data models and query languages. This will solidify the understanding of the fundamental principles of graph data extraction, exchange, processing, and analysis, as illustrated in Figure 1 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 427,
                    "end": 435,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": ""
        },
        {
            "text": "A second important element is the vision of an ecosystem governing big-graph processing systems and enabling the tuning of various components such as OLAP/OLTP operations, workloads, standards and performance needs (Section 3).",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "The authors of this article met in December 2019 in Dagstuhl for Seminar 19491 on Big Graph Processing Systems. a The seminar gathered a diverse group of 41 high-quality researchers from the data management and large-scale systems communities. It was an excellent opportunity to start the discussion about next-decade opportunities and challenges for graph processing. This is a community publication. The first four authors co-organized the community-event leading to this article and coordinated the creation of this manuscript. All other authors contributed equally to this research. a https://www.dagstuhl.de/en/program/calendar/semhp/?semnr=19491 These aspects make the big processing systems more complicated than what seen in the last decade. Figure 1 provides a high-level perception of this complexity in terms of inputs, outputs, processing needs, and final consumption of graph data.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 750,
                    "end": 758,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Sidebar A: A Joint Effort by the Computer Systems and Data Management Communities"
        },
        {
            "text": "A third element is how to understand and control performance in these future ecosystems (Section 4). We have important challenges to overcome in performance, from methodological aspects about performing meaningful, tractable, and reproducible experiments, to practical aspects regarding the trade-off of scalability with portability and interoperability.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sidebar A: A Joint Effort by the Computer Systems and Data Management Communities"
        },
        {
            "text": "Abstractions are widely used in programming languages, computational systems, database systems, etc., to conceal technical aspects in favor of more user-friendly, domain-oriented logical views. Currently, users have to choose from a large spectrum of graph data models that are similar, but differ in terms of expressiveness, cost, and intended use for querying and analytics. This 'abstraction soup' poses significant challenges to be solved for the future.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ABSTRACTIONS"
        },
        {
            "text": "Today, graph data management faces many data models (directed graphs, RDF, variants of Property Graphs, etc.), with key challenges: (a) deciding which data model to choose per use case, and (b) mastering interoperability of data models where data from different models is combined (as in the left-hand side of Figure 1 ). Both challenges require deepening our understanding of data models regarding:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 310,
                    "end": 318,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Understanding data models"
        },
        {
            "text": "(1) How do humans conceptualize data and data operations? How do data models and their respective operators support or hinder the human thought-process? Can we measure how \"natural\" or \"intuitive\" data models and their operators are?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Understanding data models"
        },
        {
            "text": "(2) How can we quantify, compare, and (partially) order the (modelling and operational) expressive power of data models? Concretely, Figure 2 illustrates a lattice for a selection of graph data-models. Read bottom-up, this lattice shows which characteristic has to be added to a graph data model to obtain a model of richer expressiveness. The figure also underlines the diversity of data models used in theory, algorithms, standards, and relevant 9 industry systems. How to extend this comparative understanding across multiple data model families, such as graph, relational, document? Which costs and benefits of choosing one model over another? (3) Interoperability between different data models can be achieved by means of mappings (semantic assertions across concepts in different data models) or with direct translations (e.g. W3C's R2RML). Are there general ways or building blocks for expressing such mappings (e.g. category theory)?",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 133,
                    "end": 141,
                    "text": "Figure 2",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Understanding data models"
        },
        {
            "text": "Studying (1) requires foremost investigating people working with data and data models, which is uncommon in the data management field and should be conducted collaboratively with other fields, such as human-computer interaction (HCI). Work on HCI and graphs exists, e.g., in HILDA workshops at Sigmod; however, these are not exploring the search space of graph data models. Studying (2) and (3) can build on existing work in database theory, but can also leverage findings from neighboring computer science communities on comparison, featurization, graph summarization, visualization and transformation of models. As an example, graph summarization [26] has been widely exploited in order to provide succinct representations of graph properties in graph mining [27] but they have seldom been used by graph processing systems to make processing more efficient, more effective, and more user-centered. For instance, approximate query processing for property graphs cannot rely on sampling as done by its relational counterpart and might need to use quotient summaries for query answering.",
            "cite_spans": [
                {
                    "start": 649,
                    "end": 653,
                    "text": "[26]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 761,
                    "end": 765,
                    "text": "[27]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "Understanding data models"
        },
        {
            "text": "Logic provides a unifying formalism for expressing queries, optimizations, integrity constraints, and integration rules.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logic-based and declarative formalisms"
        },
        {
            "text": "Starting from Codd's seminal insight relating logical formulae to relational queries [3] , many First Order (FO) logic fragments have been used to formally define query languages with desirable properties such as decidable evaluation.",
            "cite_spans": [
                {
                    "start": 85,
                    "end": 88,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Logic-based and declarative formalisms"
        },
        {
            "text": "Graph query languages are essentially a syntactic variant of FO augmented with recursive capabilities. Logic provides a yardstick for reasoning about graph queries and graph constraints. Indeed, a promising line of research is the application of formal tools, such as model checking, theorem proving [4] , and testing, to establishing the functional correctness of complex graph-processing systems, in general, and of graph database systems, in particular.",
            "cite_spans": [
                {
                    "start": 300,
                    "end": 303,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Logic-based and declarative formalisms"
        },
        {
            "text": "The influence of logic is pivotal not only to database languages, but also as a foundation for combining logical reasoning with statistical learning in AI. Logical reasoning derives categorical notions about a piece of data by logical deduction. Statistical learning derives categorical notions by learning statistical models on known data and applying it to new data. Both leverage the topological structure of graphs (ontologies and knowledge graphs, 10 graph embeddings (e.g.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logic-based and declarative formalisms"
        },
        {
            "text": "Node2vec) 3 to produce better insights than on non-connected data). However, both happen to be isolated. Combining both techniques can provide crucial advancements. As an example, deep learning (unsupervised feature learning) applied to graphs allows us to infer structural regularities and obtain meaningful representations for graphs that can be further leveraged by indexing and querying mechanisms in graph databases and exploited for logical reasoning. As another example, probabilistic models and causal relationships can be naturally encoded in property graphs and are the basis of advanced graph neural networks. 11 Property graphs allow us to synthesize more accurate models for machine learning pipelines due to their inherent expressivity and embedded domain knowledge. These considerations unveil important open questions as follows: How can statistical learning and graph processing and reasoning be combined and integrated? Which underlying formalisms make this possible? How to weigh between the two mechanisms?",
            "cite_spans": [
                {
                    "start": 621,
                    "end": 623,
                    "text": "11",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Logic-based and declarative formalisms"
        },
        {
            "text": "Currently, there is no standard graph algebra. The outcome of the GQL standardization project (cf. Section 3.2) could influence the design of a graph algebra alongside existing and emerging use-cases [12] . However, next-generation graph processing systems should address questions about their algebraic components. What are fundamental operators of this algebra, compared to other algebras (relation algebra, group algebra, quiver or path algebra, incidence algebra or monadic algebra comprehensions)? What core graph-algebra should be supported by graph processing systems? Are there graph analytical operators to include in this algebra? Can this graph algebra be combined and integrated with an algebra of types, to make type-systems more expressive and to facilitate type checking?",
            "cite_spans": [
                {
                    "start": 200,
                    "end": 204,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Algebraic operators for graph processing"
        },
        {
            "text": "A \"relational-like\" graph algebra able to express all the first-order queries [5] and enhanced with a graph pattern matching operator [28] seems like a good starting point. However, the most interesting graph-oriented queries are navigational (i.e., reachability queries) and cannot be expressed with limited recursion of relational algebra [7, 8] .",
            "cite_spans": [
                {
                    "start": 78,
                    "end": 81,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 134,
                    "end": 138,
                    "text": "[28]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 341,
                    "end": 344,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 345,
                    "end": 347,
                    "text": "8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Algebraic operators for graph processing"
        },
        {
            "text": "Furthermore, relational algebra is a closed algebra, i.e., input(s) and output of each operator is a relation, which make relational algebra operators composable. Should we aim for a closed graph algebra that encompasses both relations and graphs?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algebraic operators for graph processing"
        },
        {
            "text": "Current graph query engines combine algebra operators and ad-hoc graph algorithms into complex workloads (cf.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algebraic operators for graph processing"
        },
        {
            "text": "Sidebar B: In-Depth: Known properties of graph-processing workloads Graph workloads may exhibit several properties:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Section 3.1). This complicates implementation and affects performance. An implementation based on a single algebra"
        },
        {
            "text": "(1) Graph workloads are useful for many, vastly diverse domains [12] [13] [14] [15] . Notable features include edge orientation, properties/timestamps for edges and nodes; graph methods (neighborhood statistics, pathfinding and traversal, and subgraph mining); programming models (thinklike-a-vertex, think-like-an-edge, and think-like-a-subgraph); diverse graph sizes, including trillion-edge graphs [15] ; and query and process selectivities [1] . (2) Graph workloads can be highly irregular, mixing (short-term) data-intensive and computeintensive phases [15] . The source of irregularity, e.g., different datasets and algorithms, and computing platforms, affects performance greatly. Their interdependency forms the Hardware-Platform-Algorithm-Dataset (HPAD) Law [13] . (3) Graph processing uses a complex pipeline, combining a variety of tasks other than querying and algorithms [12, 27] . From traditional data-management, workloads include: transactional (OLTP) workloads in multi-user environments, with many short, discrete, likely atomic transactions; and analytical (OLAP) workloads with fewer users but complex and resourceintensive queries or processing jobs, with longer runtime (e.g., minutes). Popular tasks also include ETL; visualization; cleaning; mining; and debugging and testing, including synthetic graph generation. (4) Scalability, interactivity, and usability affect how graph users construct their workloads [12] . also seems utopic. A query language with general Turing Machine capabilities (like a programming language), however, entails tractability and feasibility problems [6] . Algebraic operators that work in both centralized and distributed environments, and that can be exploited by both graph algorithms and machine learning models, including GNNs, graphlets, and graph embeddings, could be highly desirable for the future.",
            "cite_spans": [
                {
                    "start": 64,
                    "end": 68,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 69,
                    "end": 73,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 74,
                    "end": 78,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 79,
                    "end": 83,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 401,
                    "end": 405,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 444,
                    "end": 447,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 558,
                    "end": 562,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 767,
                    "end": 771,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 884,
                    "end": 888,
                    "text": "[12,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 889,
                    "end": 892,
                    "text": "27]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 1435,
                    "end": 1439,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1605,
                    "end": 1608,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Section 3.1). This complicates implementation and affects performance. An implementation based on a single algebra"
        },
        {
            "text": "Ecosystems behave differently from mere systems of systems, because they couple many systems developed for different purposes and with different processes. Figure 1 exemplifies the complexity of a graph processing ecosystem through high-performance OLAP and OLTP pipelines working together. What are the ecosystem-related challenges?",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 156,
                    "end": 164,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "ECOSYSTEMS"
        },
        {
            "text": "Workloads affect both the functional requirements (what a graph processing ecosystem will be capable of doing) and the non-functional (how well). Survey data [12] point to pipelines as in Figure 1 : complex workflows, combining heterogeneous queries and algorithms, managing and processing diverse datasets, with characteristics summarized by Sidebar B.",
            "cite_spans": [
                {
                    "start": 158,
                    "end": 162,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [
                {
                    "start": 188,
                    "end": 196,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Workloads in graph processing ecosystems"
        },
        {
            "text": "In Figure 1 , graph processing links to domain-specific processing ecosystems, including simulation and numerical methods in science and engineering, aggregation and modeling in business analytics, and ranking and recommendation in social media; and to general processing, including machine learning.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 3,
                    "end": 11,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Workloads in graph processing ecosystems"
        },
        {
            "text": "Graph-processing ecosystem standards can provide a common technical foundation, thereby increasing the mobility of applications, tooling, developers, users, and stakeholders. Standards for both OLTP and OLAP workloads should standardize the data model, the data manipulation and data definition language, and the exchange formats. Fig. 3 . A reference architecture for graph processing ecosystems. The infrastructure layer (Layer 1) provides physical and virtual resources. The operating services layer (L2) provides services across resources, including data streaming and synchronization. The resource managers layer (L3) provides static and dynamic resource management and scheduling across resources. The back-end (L4) and front-end (L5) layers represent specialization efforts. Conversely, layers L2 and L3 may generalize techniques initially developed in L4-5. be easily adoptable by existing implementations, and also enable new implementations in the SQL-based technological landscape. It is important that standards reflect existing industry practices, by following widely used graph query languages. To this end, in 2019, ISO/IEC started a project to define a new graph query language, GQL. GQL is backed by backing of ten national standards bodies with representatives from major vendors in the industry and supported by the property graph community as represented by the Linked Data Benchmarks Council (LDBC). 12 With an initial focus on transactional workloads, GQL will support composable graph querying over multiple possibly overlapping graphs using enhanced Regular Path Queries (RPQs) [7] , graph transformation (views), and graph updating capabilities. GQL enhances RPQs with pattern quantification, ranking, and path-aggregation. Syntactically, GQL combines SQL-style with visual graph patterns pioneered by Cypher [14] .",
            "cite_spans": [
                {
                    "start": 860,
                    "end": 865,
                    "text": "L4-5.",
                    "ref_id": null
                },
                {
                    "start": 1421,
                    "end": 1423,
                    "text": "12",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1602,
                    "end": 1605,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1834,
                    "end": 1838,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [
                {
                    "start": 331,
                    "end": 337,
                    "text": "Fig. 3",
                    "ref_id": null
                }
            ],
            "section": "Standards for data models and query languages"
        },
        {
            "text": "Long-term, worthwhile for standardization are building blocks of graph algorithms, analytical APIs and workflow definitions, graph embedding techniques, and benchmarks (cf. [21] ). However, broad adoption for these aspects requires maturation.",
            "cite_spans": [
                {
                    "start": 173,
                    "end": 177,
                    "text": "[21]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Standards for data models and query languages"
        },
        {
            "text": "We identify the challenge of defining a reference architecture for big graph processing. The early definition of a reference architecture has greatly benefitted the discussion around the design, development, and deployment of cloud and grid computing solutions [17] .",
            "cite_spans": [
                {
                    "start": 261,
                    "end": 265,
                    "text": "[17]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Reference architecture"
        },
        {
            "text": "For big graph processing, our main insight is that many graph processing ecosystems match the common reference architecture of datacenters [18] , from which Figure 3 derives. The Spark ecosystem depicted here is one among thousands of possible instantiations. The challenge is to capture the evolving graph-processing field.",
            "cite_spans": [
                {
                    "start": 139,
                    "end": 143,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [
                {
                    "start": 157,
                    "end": 165,
                    "text": "Figure 3",
                    "ref_id": null
                }
            ],
            "section": "Reference architecture"
        },
        {
            "text": "Many graph platforms focus either on scale-up or on scale-out. Each has relative advantages [15] . Beyond merely reconciling scale-up and scale-out, we envision a scalability continuum: given a diverse workload, the ecosystem would decide automatically how to run it, and on what kind of heterogeneous infrastructure, meeting Service Level Agreements.",
            "cite_spans": [
                {
                    "start": 92,
                    "end": 96,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Beyond scale-up vs. scale-out"
        },
        {
            "text": "There are numerous mechanisms and techniques to enforce scale-up and scale-out decisions, such as data and work partitioning; and migration, offloading, replication, and elastic scaling. All decisions can be taken statically or dynamically, using various optimization and learning techniques.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Beyond scale-up vs. scale-out"
        },
        {
            "text": "Future graph processing ecosystems should cope with dynamic and streaming graph data. A dynamic graph extends the standard notion of a graph to account for updates (e.g., insertions, changes, deletions) such that the current and previous states can be seamlessly queried. Streaming graphs can grow indefinitely, as new data arrives. They are typically unbounded thus the underlying systems are unable to keep the entire graph state. The sliding window semantics [9] allows to unify the two notions, with insertions and deletions being considered as arrivals and removals from the window.",
            "cite_spans": [
                {
                    "start": 462,
                    "end": 465,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Dynamic and streaming aspects"
        },
        {
            "text": "Since current streaming processing technologies are fairly simple, e.g. aggregations and projections as in industrial graph processing libraries (e.g. Gelly on Apache Flink), the need for \"complex graph data streams\" is evident along with more advanced graph analytics and ML ad-hoc operators. Another research challenge is to identify the graph query processing operators that can be evaluated on dynamic and streaming graphs while taking into account recursive operators [10, 11] and path-oriented semantics, as needed for standard query languages such as GQL and G-Core [19] .",
            "cite_spans": [
                {
                    "start": 473,
                    "end": 477,
                    "text": "[10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 478,
                    "end": 481,
                    "text": "11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 573,
                    "end": 577,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Dynamic and streaming aspects"
        },
        {
            "text": "The graph processing platforms are also dynamic: Discovering, understanding, and controlling the dynamic phenomena that occur in complex graph processing ecosystems is an open challenge. As graph processing ecosystems become more mainstream and are embedded in larger data-processing pipelines, we expect to increasingly observe known systems phenomena such as performance variability, the presence of cascading failures, and autoscaling resources. What new phenomena will emerge? What programming abstractions [16] and systems techniques can respond to them?",
            "cite_spans": [
                {
                    "start": 511,
                    "end": 515,
                    "text": "[16]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Dynamic and streaming aspects"
        },
        {
            "text": "Graph processing raises unique performance challenges, from the lack of a widely used performance metric besides response time, to the methodological problem of comparing graph processing systems across architectures and tuning processes, to performance portability and reproducibility. Such challenges become even more daunting for graph processing ecosystems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "PERFORMANCE"
        },
        {
            "text": "Graph processing suffers from methodological issues as other computing disciplines [23, 2] . Running comprehensive graph-processing experiments, especially at scale, lacks tractability [1] , that is, ability to implement, deploy, and experiment within a reasonable amount of time and cost. As in other computing disciplines [23, 2] , we need new, reproducible experimental methodologies.",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 87,
                    "text": "[23,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 88,
                    "end": 90,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 185,
                    "end": 188,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 324,
                    "end": 328,
                    "text": "[23,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 329,
                    "end": 331,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Benchmarks, performance measurement, methodological aspects"
        },
        {
            "text": "Graph processing also raises unique challenges in performance measurement and benchmarking, related to complex workloads (see Sidebar B) and data-pipelines (see Figure 1 ). Even seemingly minute HPAD variations, e.g., the graph's degree distribution, can have significant performance implications [24, 25] . The lack of interoperability (see Section 4.2) hinders fair comparisons and benchmarking. Indexing and sampling techniques might prove to be useful to improve and predict the runtime and performance of graph queries [8, 29, 30] , challenging the communities of large-scale systems, data management, data mining, and machine learning.",
            "cite_spans": [
                {
                    "start": 297,
                    "end": 301,
                    "text": "[24,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 302,
                    "end": 305,
                    "text": "25]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 342,
                    "end": 354,
                    "text": "Section 4.2)",
                    "ref_id": null
                },
                {
                    "start": 524,
                    "end": 527,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 528,
                    "end": 531,
                    "text": "29,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 532,
                    "end": 535,
                    "text": "30]",
                    "ref_id": "BIBREF30"
                }
            ],
            "ref_spans": [
                {
                    "start": 161,
                    "end": 169,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Benchmarks, performance measurement, methodological aspects"
        },
        {
            "text": "Graph processing systems rely on complex runtimes combining software and hardware platforms. Capturing systemunder-test performance, including parallelism, distribution, streaming vs. batch operation, etc., and testing the operation of possibly hundreds of libraries, services, and runtime systems present in real-world deployments, is daunting.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Benchmarks, performance measurement, methodological aspects"
        },
        {
            "text": "We envision a combination of approaches: As in other computing disciplines [23, 2] , we need new, reproducible experimental methodologies. Concrete questions arise: How to facilitate quick yet meaningful performance-testing?",
            "cite_spans": [
                {
                    "start": 75,
                    "end": 79,
                    "text": "[23,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 80,
                    "end": 82,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Benchmarks, performance measurement, methodological aspects"
        },
        {
            "text": "How to define more faithful metrics for executing a graph algorithm, query, program, or workflow? How to generate workloads with combined operations, covering temporal, spatial, and streaming aspects? How to benchmark pipelines including machine learning and simulation? We also need organizations such as the Linked Data Benchmark Council (LDBC) to curate benchmark sharing and to audit their use in practice.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Benchmarks, performance measurement, methodological aspects"
        },
        {
            "text": "There is considerable tension between specializing graph processing stacks for performance reasons and enabling productivity for the domain scientist, through portability and interoperability.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Specialization vs. portability and interoperability"
        },
        {
            "text": "Specialization, through custom software and especially hardware acceleration, leads to significant performance improvements. Specialization to graph-workloads (see Sidebar B) focuses on diversity and irregularity 13 The HPC domain proposed specialized abstractions and C++ libraries for them, and high-performance and efficient runtimes across heterogeneous hardware. Examples include BGL [21] , CombBLAS, and GraphBLAS. Data management approaches, e.g., Neo4j, GEMS [22] , and Cray's Urika, focus on convenient query languages such as SPARQL and Cypher to ensure portability. Ongoing work also focuses on (custom) accelerators.",
            "cite_spans": [
                {
                    "start": 213,
                    "end": 215,
                    "text": "13",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 389,
                    "end": 393,
                    "text": "[21]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 467,
                    "end": 471,
                    "text": "[22]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Specialization vs. portability and interoperability"
        },
        {
            "text": "Portability through reusable components seems promising, but currently there exists no standard graph library or query language. Over 100 big-graph processing systems exist, but they do not support portability and soon graph-systems will need to support constantly evolving processes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Specialization vs. portability and interoperability"
        },
        {
            "text": "Lastly, interoperability means integrating graph processing into broader workflows, with multi-domain tools.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Specialization vs. portability and interoperability"
        },
        {
            "text": "Integration with machine learning and data mining processes, and with simulation and decision making instruments, seems vital but is not supported by existing frameworks. 13 Irregularity could be seen as the opposite of the locality principle commonly leveraged in computing.",
            "cite_spans": [
                {
                    "start": 171,
                    "end": 173,
                    "text": "13",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Specialization vs. portability and interoperability"
        },
        {
            "text": "Inspired by Vannevar Bush's 1940s concept of personal memex, and by a 2010s specialization into a Distributed Systems Memex [20] , we posit it would be both interesting and useful to create a Big Graph Memex for collecting, archiving, and retrieving meaningful operational information about such systems. This could be beneficial for learning about and eradicating performance and related issues, for enabling more creative designs and extending automation, for meaningful and reproducible testing, as feedback building-block in smart graph processing, etc.",
            "cite_spans": [
                {
                    "start": 124,
                    "end": 128,
                    "text": "[20]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "A memex for big graph processing systems"
        },
        {
            "text": "Graphs are a mainstay abstraction in today's data processing pipelines. How can future big graph processing and database systems provide highly scalable, efficient and diversified querying and analytical capabilities, as demanded by real-world requirements?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CONCLUSION"
        },
        {
            "text": "To tackle this question, we have undertaken a community approach. We started through a Dagstuhl Seminar and, shortly after, shaped the structured connections presented here. We have focused in this article on three interrelated elements: abstractions, ecosystems, and performance. For each of these elements, and across them, we have provided a view at what's next.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CONCLUSION"
        },
        {
            "text": "Only time can tell if our predictions provided worthwhile directions to the community. In the meantime, join us in solving the problems of big graph processing. The future is big graphs!",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CONCLUSION"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Graph Generators: State of the Art and Open Challenges",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bonifati",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "ACM Computing Surveys",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3379445"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Guidelines for Experimental Algorithmics: A Case Study in Network Analysis. Algorithms",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Angriman",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "12",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "A Relational Model of Data for Large Shared Data Banks",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "F"
                    ],
                    "last": "Codd",
                    "suffix": ""
                }
            ],
            "year": 1970,
            "venue": "Commun. ACM",
            "volume": "13",
            "issn": "6",
            "pages": "377--387",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "A Machine-Checked Proof of the Odd Order Theorem",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Gonthier",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "ITP",
            "volume": "",
            "issn": "",
            "pages": "163--179",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Theory of Database Queries",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "K"
                    ],
                    "last": "Chandra",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "Proc. Symposium on Principles of Database Systems",
            "volume": "",
            "issn": "",
            "pages": "1--9",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Universality of data retrieval languages",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "V"
                    ],
                    "last": "Aho",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "D"
                    ],
                    "last": "Ullman",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "Proceedings of the 6th ACM SIGACT-SIGPLAN symposium on Principles of programming languages",
            "volume": "",
            "issn": "",
            "pages": "110--119",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Foundations of modern query languages for graph databases",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Angles",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ACM Computing Surveys (CSUR)",
            "volume": "50",
            "issn": "5",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Querying Graphs. Synthesis Lectures on Data Management",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bonifati",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Models and Issues in Data Stream Systems",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Babcock",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "PODS",
            "volume": "",
            "issn": "",
            "pages": "1--16",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Regular Path Query Evaluation on Streaming Graphs",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Pacaci",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bonifati",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "T"
                    ],
                    "last": "\u00d6zsu",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Certified Graph View Maintenance with Regular Datalog. Theory Pract",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bonifati",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Dumbrava",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "J"
                    ],
                    "last": "Gallego Arias",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Log. Program",
            "volume": "18",
            "issn": "",
            "pages": "372--389",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "The ubiquity of large graphs and surprising challenges of graph processing: extended survey",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sahu",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "VLDB J",
            "volume": "29",
            "issn": "2",
            "pages": "595--618",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Exploring HPC and big data convergence: A graph processing study on Intel Knights Landing",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Uta",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "CLUSTER",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Cypher: An Evolving Query Language for Property Graphs",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Francis",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Response to \"Scale Up or Scale Out for Graph Processing",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Salihoglu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "T"
                    ],
                    "last": "\u00d6zsu",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IEEE Internet Computing",
            "volume": "22",
            "issn": "5",
            "pages": "18--24",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "High-level programming abstractions for distributed graph processing",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Vasiliki",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Vlassov",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Haridi",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "IEEE Transactions on Knowledge and Data Engineering",
            "volume": "30",
            "issn": "",
            "pages": "305--324",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "The Grid 2: Blueprint for a new computing infrastructure",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Foster",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Kesselman",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Massivizing Computer Systems: A Vision to Understand, Design, and Engineer Computer Ecosystems Through and Beyond Modern Distributed Systems",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Iosup",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "ICDCS",
            "volume": "",
            "issn": "",
            "pages": "1224--1237",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "G-CORE: A Core for Future Graph Query Languages",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Angles",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "1421--1432",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "The AtLarge Vision on the Design of Distributed Systems and Ecosystems",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Iosup",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ICDCS",
            "volume": "",
            "issn": "",
            "pages": "1765--1776",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "The Boost Graph Library: User Guide and Reference Manual",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "G"
                    ],
                    "last": "Siek",
                    "suffix": ""
                },
                {
                    "first": "L.-Q",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lumsdaine",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "In-Memory Graph Databases for Web-Scale Data",
            "authors": [
                {
                    "first": "V",
                    "middle": [
                        "G"
                    ],
                    "last": "Castellana",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "IEEE Computer",
            "volume": "48",
            "issn": "3",
            "pages": "24--35",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Methodological Principles for Reproducible Performance Evaluation in Cloud Computing",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "V"
                    ],
                    "last": "Papadopoulos",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE Trans. on Sw. Eng",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "LDBC Graphalytics: A Benchmark for Large-Scale Graph Analysis on Parallel and Distributed Platforms",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Iosup",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "9",
            "issn": "",
            "pages": "1317--1328",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "How Representative Is a SPARQL Benchmark? An Analysis of RDF Triplestore Benchmarks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Saleem",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "1623--1633",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Graph Summarization Methods and Applications: A Survey",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Safavi",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Dighe",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Koutra",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "ACM Comput. Surv",
            "volume": "51",
            "issn": "3",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Managing and Mining Graph Data. Advances in Database Systems",
            "authors": [
                {
                    "first": "C-C",
                    "middle": [],
                    "last": "Aggarwal",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "40",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Graphs-at-a-time: query language and access methods for graph databases",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "He",
                    "suffix": ""
                },
                {
                    "first": "A-K",
                    "middle": [],
                    "last": "Singh",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "SIGMOD Conference",
            "volume": "",
            "issn": "",
            "pages": "405--418",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Sampling from large graphs",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Leskovec",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Faloutsos",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "KDD",
            "volume": "",
            "issn": "",
            "pages": "631--636",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "On Graph Query Optimization in Large Networks",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Zhao",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Han",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Proc. VLDB Endow",
            "volume": "3",
            "issn": "1",
            "pages": "340--351",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Example lattice showing graph data model variants with their model characteristics, cf.[8].",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "in graph processing: sheer dataset-scale (addressed by Pregel, later by the open-source project Giraph), the (truncated) powerlaw-like distributions for vertex degrees (PowerGraph), localized and community-oriented updates (GraphChi), diverse vertex-degree distributions across datasets (PGX.D, PowerLyra), irregular or non-local vertex access (Mosaic), affinity to specialized hardware (the BGL family, HAGGLE, rapids.ai), etc.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "application domains, including biology, security, logistics and planning, social sciences, chemistry, and finance, see http://arxiv.org/abs/1807.00382 2 Cf. https://app.databox.com/datawall/551f309602080e2b2522f7446a20adb705cabbde8 3 https://www.oreilly.com/library/view/graph-algorithms/9781492047674/ 4 Many highly cited articles support this statement, e.g, Hamilton, W., Zhitao, Y., and Leskovec, J. Inductive representation learning on large graphs. NIPS (2017); Perozzi, B., Al-Rfou, R., Skiena S. DeepWalk: Online Learning of Social Representations. https://arxiv.org/pdf/1403.6652.pdf 5 https://neo4j.com/graphs4good/covid-19/6 The summary of the Dagstuhl seminar: https://www.dagstuhl.de/19491",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "ISO/IEC GQL Property Graph ModelSingle vertex labels, vertex properties, edge properties Hyper vertices",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "They should",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}